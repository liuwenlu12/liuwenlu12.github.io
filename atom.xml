<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://liuwenlu12.github.io/</id>
    <title>刘文路的博客</title>
    <updated>2019-12-15T14:23:57.527Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://liuwenlu12.github.io/"/>
    <link rel="self" href="https://liuwenlu12.github.io//atom.xml"/>
    <subtitle>希望你过得比谁都好，希望我永远不知道
</subtitle>
    <logo>https://liuwenlu12.github.io//images/avatar.png</logo>
    <icon>https://liuwenlu12.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, 刘文路的博客</rights>
    <entry>
        <title type="html"><![CDATA[SpringBoot整合Mybtatis-Plus]]></title>
        <id>https://liuwenlu12.github.io//post/ce-shi</id>
        <link href="https://liuwenlu12.github.io//post/ce-shi">
        </link>
        <updated>2019-11-11T12:23:57.000Z</updated>
        <content type="html"><![CDATA[<h3 id="简介">简介</h3>
<p>MyBatis-Plus（简称 MP）是一个 MyBatis 的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。</p>
<h3 id="添加依赖">添加依赖</h3>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;com.baomidou&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;
    &lt;version&gt;3.1.2&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h3 id="特性">特性</h3>
<h4 id="无侵入">无侵入：</h4>
<p>只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑</p>
<h4 id="损耗小">损耗小：</h4>
<p>启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作</p>
<h4 id="强大的-crud-操作">强大的 CRUD 操作：</h4>
<p>内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作，更有强大的条件构造器，满足各类使用需求</p>
<h4 id="支持-lambda-形式调用">支持 Lambda 形式调用：</h4>
<p>通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错</p>
<h4 id="支持主键自动生成">支持主键自动生成：</h4>
<p>支持多达 4 种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由配置，完美解决主键问题</p>
<h4 id="支持-activerecord-模式">支持 ActiveRecord 模式：</h4>
<p>支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可进行强大的 CRUD 操作</p>
<h4 id="支持自定义全局通用操作">支持自定义全局通用操作：</h4>
<p>支持全局通用方法注入（ Write once, use anywhere ）</p>
<h4 id="内置代码生成器">内置代码生成器：</h4>
<p>采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、 Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用</p>
<h4 id="内置分页插件">内置分页插件：</h4>
<p>基于 MyBatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 List 查询</p>
<h4 id="分页插件支持多种数据库">分页插件支持多种数据库：</h4>
<p>支持 MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、Postgre、SQLServer2005、SQLServer 等多种数据库</p>
<h4 id="内置性能分析插件">内置性能分析插件：</h4>
<p>可输出 Sql 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询</p>
<h4 id="内置全局拦截插件">内置全局拦截插件：</h4>
<p>提供全表 delete 、 update 操作智能分析阻断，也可自定义拦截规则，预防误操作</p>
<h3 id="通用mapper">通用Mapper</h3>
<h4 id="实体类bookjava">实体类Book.java</h4>
<pre><code>@TableName(&quot;book&quot;) //当数据库表名与实体类不同时
public class Book {
    //使用TableId注解标记主键对应的属性
    //value：主键的字段名
    //type：主键的生成策略，IdType.AUTO：使用数据库的自增
    @TableId(value = &quot;id&quot;,type = IdType.AUTO)
    private Long id;
    private String name;
    private String author;
    private Double price;
		@TableLogic //逻辑删除
		private Integer  status;
		@TableField(exist = false) //当此属性在表中没有时
		priver  String NO;
    //省略getter和setter
}
</code></pre>
<h4 id="让mapper接口继承自basemapper接口">让Mapper接口继承自BaseMapper接口</h4>
<pre><code>import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import com.oaec.springbootmp.entity.Book;

public interface BookMapper extends BaseMapper&lt;Book&gt; {
}
测试根据编号查询
@SpringBootTest
public class SpringbootMpApplicationTests {

    @Autowired
    private BookMapper bookMapper;

    @Test
    public void contextLoads() {
        Book book = bookMapper.selectById(1001);
        System.out.println(&quot;book = &quot; + book);
    }

}
</code></pre>
<h4 id="增删改">增删改</h4>
<h4 id="插入数据">插入数据</h4>
<pre><code>Book book = new Book();
book.setName(&quot;红楼梦&quot;);
book.setAuthor(&quot;曹雪芹&quot;);
book.setPrice(19.92);
//返回值代表影响数据库的行数
int insert = bookMapper.insert(book);
System.out.println(&quot;insert = &quot; + insert);
//插入成功之后自动将生成的主键保存在主键对应的属性
System.out.println(&quot;book = &quot; + book);
</code></pre>
<h4 id="根据主键更新">根据主键更新</h4>
<pre><code>Book book = new Book();
book.setId(1003L);
//        book.setName(&quot;三国演义&quot;);
book.setAuthor(&quot;罗贯中&quot;);
//根据主键进行数据更新，只会更新赋值的属性，值为null的属性不会进行修改
int i = bookMapper.updateById(book);
System.out.println(&quot;i = &quot; + i);
</code></pre>
<h4 id="自定义条件更新数据">自定义条件更新数据</h4>
<pre><code>Book book = new Book();
book.setPrice(10D);
//将价格大于20的书，价格修改为10
//第一个参数的属性会拼接在set之后，第二个参数的条件会拼接在where之后
int update = bookMapper.update(book,
        Wrappers.&lt;Book&gt;lambdaUpdate().gt(Book::getPrice, 20));
System.out.println(&quot;update = &quot; + update);
</code></pre>
<h4 id="根据主键删除">根据主键删除</h4>
<p><code>bookMapper.deleteById(1161463992506478594L);</code></p>
<h4 id="根据主键批量删除">根据主键批量删除</h4>
<pre><code>List&lt;Long&gt; idList = Arrays.asList(1006L, 1007L);
int i = bookMapper.deleteBatchIds(idList);
</code></pre>
<h4 id="使用map作为条件删除">使用Map作为条件删除</h4>
<pre><code>Map&lt;String,Object&gt; map = new HashMap&lt;&gt;();
map.put(&quot;name&quot;,&quot;西游记&quot;);
int i = bookMapper.deleteByMap(map);
</code></pre>
<h4 id="使用条件构造器删除">使用条件构造器删除</h4>
<pre><code>int delete = bookMapper.delete(Wrappers.&lt;Book&gt;lambdaUpdate()
                .lt(Book::getPrice, 20));
</code></pre>
<h3 id="查询">查询</h3>
<h4 id="根据主键查询">根据主键查询</h4>
<p><code>Book book = bookMapper.selectById(1003)</code></p>
<h4 id="查询全部">查询全部</h4>
<p><code>List&lt;Book&gt; books = bookMapper.selectList(null);</code></p>
<h4 id="自定义查询条件">自定义查询条件</h4>
<pre><code>//查询价格大于10元的书
List&lt;Book&gt; books = bookMapper.selectList(Wrappers.&lt;Book&gt;lambdaQuery()
                .gt(Book::getPrice, 10));
//查询价格大于10元的书，书名为“三国演义”
List&lt;Book&gt; books = bookMapper.selectList(Wrappers.&lt;Book&gt;lambdaQuery()
                .gt(Book::getPrice, 10)
                .eq(Book::getName, &quot;三国演义&quot;));
//查询书名包含“三”的书
List&lt;Book&gt; books = bookMapper.selectList(Wrappers.&lt;Book&gt;lambdaQuery()
                .like(Book::getName, &quot;三&quot;));
//查询书名以“三”开头的书
List&lt;Book&gt; books = bookMapper.selectList(Wrappers.&lt;Book&gt;lambdaQuery()
                .likeRight(Book::getName, &quot;三&quot;));
</code></pre>
<h3 id="分页查询">分页查询</h3>
<h4 id="配置类mybatisplusconfig">配置类：MybatisPlusConfig</h4>
<pre><code>/**
 * 配置类
 */
@Configuration
public class MybatisPlusConfig {
    @Bean
    public PaginationInterceptor paginationInterceptor(){
        return new PaginationInterceptor();
    }
}
查询第1页，每页2条
//查询结果为实体类型
IPage&lt;Book&gt; page = bookMapper.selectPage(new Page&lt;Book&gt;(1, 2), null);
//查询结果为Map类型
IPage&lt;Map&lt;String, Object&gt;&gt; page = bookMapper.selectMapsPage(new Page&lt;&gt;(1, 2), null);
IPage接口
List getRecords(); 获取查询记录
long getTotal(); 获取总数量
long getPages() 获取总页数
通用Service
Service接口继承IService
import com.baomidou.mybatisplus.extension.service.IService;
import com.oaec.springbootmp.entity.Book;

public interface BookService extends IService&lt;Book&gt; {
}
Service实现类继承ServiceImpl，实现自己的Service接口
import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import com.oaec.springbootmp.entity.Book;
import com.oaec.springbootmp.mapper.BookMapper;
import com.oaec.springbootmp.service.BookService;
import org.springframework.stereotype.Service;

@Service(&quot;bookService&quot;)
public class BookServiceImpl extends ServiceImpl&lt;BookMapper, Book&gt; implements BookService {
}
</code></pre>
<h4 id="逻辑删除">逻辑删除</h4>
<pre><code>application.yml配置文件中配置代表是否删除的数值
mybatis-plus:
  global-config:
    db-config:
      logic-delete-value: 0 # 逻辑已删除值(默认为 0)
      logic-not-delete-value: 1 # 逻辑未删除值(默认为 1)
实体中表示是否删除的属性添加注解
public class Book {
    @TableId(type = IdType.AUTO)
    private Long id;
    private String name;
    private Double price;
    //逻辑删除字段
    @TableLogic
    private Integer status;
    private Timestamp createTime;
    //省略getter和setter
}
执行查询
List&lt;Book&gt; books = bookMapper.selectList(null);
books.forEach(System.out::println);
​	执行的SQL

SELECT id,name,price,status,create_time FROM book WHERE status=1
执行删除
int i = bookMapper.deleteById(1L);
System.out.println(&quot;i = &quot; + i);
​	执行的SQL

UPDATE book SET status=0 WHERE id=? AND status=1
备注
jdk1.8才支持lambda表达式，如果使用jdk1.8之前的版本，可以使用Wrappers.query()
List&lt;Book&gt; books = bookMapper.selectList(Wrappers.&lt;Book&gt;query().like(&quot;name&quot;, &quot;三&quot;));
for (Book book : books) {
    System.out.println(&quot;book = &quot; + book);
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://liuwenlu12.github.io//post/hello-gridea</id>
        <link href="https://liuwenlu12.github.io//post/hello-gridea">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="https://gridea.dev/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>Windows</strong>，<strong>MacOS</strong> 或 <strong>Linux</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前 🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
</feed>